---
layout: post
keywords: 
description: 
title: python调用父类方法 
categories: [python]
tags: [python,class]
group: archive
icon: [code]
featured: false
---

<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1 类中方法定义</a></li>
<li><a href="#sec-2">2 python在子类中调用父类的访问有一下两种方式</a>
<ul>
<li><a href="#sec-2-1">2.1 通过类名调用，self显式传递</a></li>
<li><a href="#sec-2-2">2.2 通过super机制</a>
<ul>
<li><a href="#sec-2-2-1">2.2.1 新式类和经典类是什么</a></li>
<li><a href="#sec-2-2-2">2.2.2 新式类和经典类的区别</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1">类中方法定义</h2>
<div class="outline-text-2" id="text-1">

<p>python类中的方法定义第一个参数一般都命名为self，用于传递对象本身，而调用方法时不用显示传递，系统会自动传递。
</p>


<pre class="example">&gt;&gt;&gt; class Base(object):
... def func(self,message):
... print message
...
&gt;&gt;&gt; Base().func('hello world')
hello world
</pre>

</div>

</div>

<div id="outline-container-2" class="outline-2">
<h2 id="sec-2">python在子类中调用父类的访问有一下两种方式</h2>
<div class="outline-text-2" id="text-2">


</div>

<div id="outline-container-2-1" class="outline-3">
<h3 id="sec-2-1">通过类名调用，self显式传递</h3>
<div class="outline-text-3" id="text-2-1">




<pre class="example">class Base():
    def meth(self):
        print "i'm base" 
class Derived(Base):
    def meth(self):
        Base.meth(self)
        print "this is derived" 
print Derived().meth()
#结果
i'm base
this is derived
None
</pre>

<p>
注：这里的None是因为无return的函数默认返回None。也就是meth()默认返回None。
</p>
<p>
缺点是当父类名发生变化是，子类中涉及的地方都需要更改，代码量庞大的时候，是非常不便的。
</p></div>

</div>

<div id="outline-container-2-2" class="outline-3">
<h3 id="sec-2-2">通过super机制</h3>
<div class="outline-text-3" id="text-2-2">




<pre class="example">class Base(object):
    def meth(self):
        print "i'm base" 
class Derived(Base):
    def meth(self):
        super(Derived,self).meth()
        print "this is derived" 
print Derived().meth()
#结果
i'm base
this is derived
None
</pre>

<p>
可以这样理解,对于super(Derived, self).meth()：super(Derived, self)首先找到Derived的父类（就是类Base），然后把类Derived的对象self转换为类Base的对象，然后“被转换”的类Base对象调用自己的meth函数。
</p>
<p>
此处有一个问题，如果第二段代码第一句写成class Base:会报错TypeError: must be type, not classobj。这是因为super只能用于新式类(new-style class),不能用于经典类(classic class)。
</p>

</div>

<div id="outline-container-2-2-1" class="outline-4">
<h4 id="sec-2-2-1">新式类和经典类是什么</h4>
<div class="outline-text-4" id="text-2-2-1">

<dl>
<dt>新类</dt><dd>所有类都必须要有继承的类，如果什么都不想继承，就显示的从object继承。
</dd>
<dt>经典类</dt><dd>什么都不用继承的类，如上面的代码就是经典类。所以报错。
</dd>
</dl>


<p>
python2.2开始引入新式类。新式类统一了类(class)和类型(type)，并添加了新的属性。
</p></div>

</div>

<div id="outline-container-2-2-2" class="outline-4">
<h4 id="sec-2-2-2">新式类和经典类的区别</h4>
<div class="outline-text-4" id="text-2-2-2">

<dl>
<dt>新式类</dt><dd>所有类都必须要有继承的类，如果什么都不想继承，就继承到object类。基类搜索机制是广度优先遍历。
</dd>
<dt>经典类</dt><dd>没有父类。基类搜索机制是深度优先遍历
</dd>
</dl>




<pre class="example">#!/usr/bin/python
""" classic class """
class CA():
    var = 'a'
class CB(CA):
    pass
class CC(CA):
    var = 'c'
class CD(CB, CC):
    pass
""" new-style class """
class NA(object):
    var = 'a'
class NB(NA):
    pass
class NC(NA):
    var = 'c'
class ND(NB, NC):
    pass
if __name__ == "__main__":
    print CD.var
    print ND.var
    ca = CA()
    na = NA()
    print ca.__class__
    print type(ca)
    print dir(ca)
    print na.__class__
    print type(na)
    print dir(na)

#输出
a
c
__main__.CA
&lt;type 'instance'&gt;
['__doc__', '__module__', 'var']
&lt;class '__main__.NA'&gt;
&lt;class '__main__.NA'&gt;
['__class__', '__delattr__', '__dict__', '__doc__', '__format__', '__getattribute__', '__hash__', '__init__', '__module__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'var']
</pre>

<p>
看到CD.var的值是'a',而ND.var的值是 'c'
</p>
<p>
<b>Google python风格鼓励使用新式类</b>
</p></div>
</div>
</div>
</div>
