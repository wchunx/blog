---
layout: post
keywords: 
description: 
title: Python minidom解析XML
categories: [Python]
tags: [Python, xml, minidom]
group: archive
icon: code
featured: false
---


<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1 Python minidom解析XML</a>
<ul>
<li><a href="#sec-1-1">1.1 导入模块</a></li>
<li><a href="#sec-1-2">1.2 解析xml文件或字符串</a></li>
<li><a href="#sec-1-3">1.3 获取节点</a>
<ul>
<li><a href="#sec-1-3-1">1.3.1 节点属性</a></li>
<li><a href="#sec-1-3-2">1.3.2 访问子节点</a></li>
</ul>
</li>
<li><a href="#sec-1-4">1.4 生成XML</a></li>
<li><a href="#sec-1-5">1.5 一个完整的xml</a></li>
<li><a href="#sec-1-6">1.6 参考资料</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1">Python minidom解析XML</h2>
<div class="outline-text-2" id="text-1">

<p>DOM是Document Object Model的简称，它是以对象树来表示一个XML文档的方法，使用它的好处就是你可以非常灵活的在对象中进行遍历。minidom从名字就可以看出这是dom的一个mini实现模块。
</p>
<p>
test.xml
</p>


<pre class="example">&lt;?xml version="1.0"?&gt;
&lt;doc&gt; 
  &lt;branch1 name="one" num="001"&gt;
     beijing
  &lt;/branch1&gt;
  &lt;branch2 name="two" num="002"&gt;
    &lt;sub-branch2 name="twenty-one"&gt;
      heibei
    &lt;/sub-branch2&gt;
  &lt;/branch2&gt;
  &lt;branch3&gt;shanghai&lt;/branch3&gt;
&lt;/doc&gt;
</pre>


</div>

<div id="outline-container-1-1" class="outline-3">
<h3 id="sec-1-1">导入模块</h3>
<div class="outline-text-3" id="text-1-1">




<pre class="example">import xml.dom.minidom as minidom 
</pre>

</div>

</div>

<div id="outline-container-1-2" class="outline-3">
<h3 id="sec-1-2">解析xml文件或字符串</h3>
<div class="outline-text-3" id="text-1-2">




<pre class="example">#解析xml文件，两种方式
dom = minidom.parse('/home/wchunx/test.xml') # parse an XML file by name

datasource = open('/home/wchunx/text.xml')
dom2 = minidom.parse(datasource)   # parse an open file
#解析xml字符串
dom3 = minidom.parseString('&lt;myxml&gt;Some data&lt;empty/&gt; some more data&lt;/myxml&gt;')
</pre>

<p>
返回一个dom对象，以一个对象树的形式表示一个XML，便于之后的操作。
</p></div>

</div>

<div id="outline-container-1-3" class="outline-3">
<h3 id="sec-1-3">获取节点</h3>
<div class="outline-text-3" id="text-1-3">




<pre class="example">#获取根节点documentElement,注意没()
root = dom.documentElement
</pre>


</div>

<div id="outline-container-1-3-1" class="outline-4">
<h4 id="sec-1-3-1">节点属性</h4>
<div class="outline-text-4" id="text-1-3-1">

<p>每一个结点都有它的nodeName，nodeValue，nodeType属性。
</p>


<pre class="example">&gt;&gt;&gt; print root.nodeName, root.nodeValue, root.nodeType
doc None 1
</pre>

<p>
nodeName为结点名字。
</p>
<p>
nodeValue是节点的值，只对文本节点有效。
</p>
<p>
nodeType是节点的类型，现在有以下几种：
</p>
<p>
‘ATTRIBUTE_NODE’,‘CDATA_SECTION_NODE’,‘COMMENT_NODE’,‘DOCUMENT_FRAGMENT_NODE’,
</p>
<p>
‘DOCUMENT_NODE’,‘DOCUMENT_TYPE_NODE’,‘ELEMENT_NODE’,‘ENTITY_NODE’,
</p>
<p>
‘ENTITY_REFERENCE_NODE’,‘NOTATION_NODE’,‘PROCESSING_INSTRUCTION_NODE’,‘TEXT_NODE’
</p></div>

</div>

<div id="outline-container-1-3-2" class="outline-4">
<h4 id="sec-1-3-2">访问子节点</h4>
<div class="outline-text-4" id="text-1-3-2">

<p>对于已经知道名字的子节点，可以通过使用getElementsByTagName()方法访问
</p>


<pre class="example">root.getElementsByTagName("branch1") #读取branch1子节点
</pre>

<p>
返回的结果是一个列表。如果要得到某节点下的所有子节点，可以使用childNodes属性:
</p>


<pre class="example">&gt;&gt;&gt; root.childNodes
[&lt;DOM Text node "u'\n  '"&gt;, &lt;DOM Element: branch1 at 0xb6f9ae6c&gt;, &lt;DOM Text node "u'\n  '"&gt;, &lt;DOM Element: branch2 at 0xb6fa102c&gt;, &lt;DOM Text node "u'\n  '"&gt;, &lt;DOM Element: branch3 at 0xb6fa128c&gt;, &lt;DOM Text node "u'\n'"&gt;]
</pre>

<p>
返回的也是个列表，childNodes只保存了当前元素的第一层子结点。从结果可以看出每行的回车被看作了文本节点。
</p>
<p>
getElementsByTagName()可以搜索当前元素的所有子元素，包括所有层次的子元素
</p>


<pre class="example">&gt;&gt;&gt; root.getElementsByTagName("sub-branch2")
[&lt;DOM Element: sub-branch2 at 0xb6fa114c&gt;]
</pre>

<p>
遍历子节点，并打印节点名字，在遍历是要先确定是Element node
</p>


<pre class="example">&gt;&gt;&gt; for node in root.childNodes:
...     if node.nodeType == node.ELEMENT_NODE:
...             print node.nodeName
... 
branch1
branch2
branch3
</pre>

<p>
感觉minidom在操作节点时并没有ElementTree方便
</p></div>
</div>

</div>

<div id="outline-container-1-4" class="outline-3">
<h3 id="sec-1-4">生成XML</h3>
<div class="outline-text-3" id="text-1-4">




<pre class="example">import xml.dom.minidom as minidom
impl = minidom.getDOMImplementation()
#生成dom对象
dom = impl.createDocument(None,'root', None)
#生成文档节点（根节点）
root = dom.documentElement
#生成Element_node item
item = dom.createElement('item')
#生成文本节点text
text = dom.createTextNode('test')
#将text作为子节点加入item，使item有文本内容
item.appendChild(text)
&lt;DOM Text node “test”&gt;
#使用setAttribute为item添加属性
item.setAttribute('id', 'idvalue')
#添加item为root的子节点
root.appendChild(item)
&lt;DOM Element: item at 0xb9cf80&gt;
print root.toxml()
&lt;root&gt;&lt;item id="idvalue"&gt;test&lt;/item&gt;&lt;/root&gt;
print dom.toxml()
&lt;?xml version="1.0" ?&gt;&lt;root&gt;&lt;item id="idvalue"&gt;test&lt;/item&gt;&lt;/root&gt;
print dom.toprettyxml()
&lt;?xml version="1.0" ?&gt;
&lt;root&gt;
    &lt;item id="idvalue"&gt;test&lt;/item&gt;
&lt;/root&gt;
print dom.toprettyxml(encoding='UTF-8')
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;root&gt;
    &lt;item id="idvalue"&gt;test&lt;/item&gt;
&lt;/root&gt;
</pre>

<p>
dom对象输出xml的方法为toxml()和toprettyxml().toxml()输出紧凑格式的XML文本,toprettyxml()输出美化后的XML文本,将每个结点后面都加入了回车符，并且自动处理缩近。.
</p>
<p>
minidom在输出xml文件时操作比较简单，可以用ElementTree创建和操作节点，minidom输出。
</p></div>

</div>

<div id="outline-container-1-5" class="outline-3">
<h3 id="sec-1-5">一个完整的xml</h3>
<div class="outline-text-3" id="text-1-5">




<pre class="example">dom对象doc,根节点对象host_node,子节点对象ip_node,port_node,status_node,
#注意节点对象名称和节点对象的text
host_ip='192.168.0.1'
host_port='7443'
host_status='7202'

import xml.dom.minidom as minidom
#生成dom对象
dom = minidom.Document()
#生成节点host_node
host_node = doc.createElement('node')
host_node.attributes['type'] = 'host'
doc.appendChild(host_node)
&lt;DOM Element: node at 0xb72988ac&gt;
#生成ip节点
ip_node = doc.createElement('ip')
ip_node.appendChild(doc.createTextNode(host_ip))
&lt;DOM Text node "'192.168.0.'..."&gt;
host_node.appendChild(ip_node)
&lt;DOM Element: ip at 0xb6e5bfcc&gt;
#生成port节点
port_node = doc.createElement('port')
port_node.appendChild(doc.createTextNode(host_port))
&lt;DOM Text node "'7443'"&gt;
host_node.appendChild(port_node)
&lt;DOM Element: port at 0xb6e6416c&gt;
#生成status节点
status_node = doc.createElement('status')
status_node.appendChild(doc.createTextNode(host_status))
&lt;DOM Text node "'7202'"&gt;
host_node.appendChild(status_node)
&lt;DOM Element: status at 0xb6a646cc&gt;
#输出
print doc.toprettyxml()
&lt;?xml version="1.0" ?&gt;
&lt;node type="host"&gt;
    &lt;ip&gt;192.168.0.1&lt;/ip&gt;
    &lt;port&gt;7443&lt;/port&gt;
    &lt;status&gt;7202&lt;/status&gt;
&lt;/node&gt;
</pre>

</div>

</div>

<div id="outline-container-1-6" class="outline-3">
<h3 id="sec-1-6">参考资料</h3>
<div class="outline-text-3" id="text-1-6">

<p><a href="http://blog.donews.com/limodou/archive/2004/07/15/43755.aspx">使用minidom来处理XML的示例</a>
</p></div>
</div>
</div>
