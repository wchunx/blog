#+BEGIN_HTML
---
layout: post
keywords: 
description: 
title: python子类调用父类方法 
categories: [python]
tags: [python,class,subclass]
group: archive
icon: code
featured: false
---
#+END_HTML
#+OPTIONS: ^:{}
Python子类调用父类的方法
* 1.Python子类调用父类的方法
#+BEGIN_SRC python
class Base():
    def meth(self):
        print "i'm base" 
class Derived(Base):
    def meth(self):
        Base.meth(self)
        print "this is derived" 
print Derived().meth()
#结果
i'm base
this is derived
None
#+END_SRC
+ 注 :: 这里的None是因为无return的函数默认返回None。也就是meth()默认返回None。缺点是如果子类多处调用父类方法，父类发生变化时需要多处修改。
* 2.使用supper
#+BEGIN_SRC python
class Base(object):
    def meth(self):
        print "i'm base" 
class Derived(Base):
    def meth(self):
        super(Derived,self).meth()
        print "this is derived" 
print Derived().meth()
#结果
i'm base
this is derived
None
#+END_SRC
可以这样理解,对于super(Derived, self).meth()：super(Derived, self)首先找到Derived的父类（就是类Base），然后把类Derived的对象self转换为类Base的对象，然后“被转换”的类Base对象调用自己的meth函数。

此处有一个问题，如果第二段代码第一句写成class Base:会报错TypeError: must be type, not classobj。这是因为super只能用于新式类(new-style class),不能用于经典类(classic class)。从python2.2开始引入新式类。新式类统一了类(class)和类型(type)，并添加了新的属性。
** 二者的区别
+ 新式类 :: 所有类都必须要有继承的类，如果什么都不想继承，就继承到object类。基类搜索机制是广度优先遍历。
+ 经典类 :: 没有父类。基类搜索机制是深度优先遍历
#+BEGIN_SRC python
#!/usr/bin/python
""" classic class """
class CA():
    var = 'a'
class CB(CA):
    pass
class CC(CA):
    var = 'c'
class CD(CB, CC):
    pass
""" new-style class """
class NA(object):
    var = 'a'
class NB(NA):
    pass
class NC(NA):
    var = 'c'
class ND(NB, NC):
    pass
if __name__ == "__main__":
    print CD.var
    print ND.var
    ca = CA()
    na = NA()
    print ca.__class__
    print type(ca)
    print dir(ca)
    print na.__class__
    print type(na)
    print dir(na)
#+END_SRC
输出
#+BEGIN_SRC python
a
c
__main__.CA
<type 'instance'>
['__doc__', '__module__', 'var']
<class '__main__.NA'>
<class '__main__.NA'>
['__class__', '__delattr__', '__dict__', '__doc__', '__format__', '__getattribute__', '__hash__', '__init__', '__module__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'var']
#+END_SRC
CD.var的值是'a',而ND.var的值是'c'
