#+BEGIN_HTML
---
layout: post
keywords: 
description: 
title: Python 多线程 
categories: [Python]
tags: [Python, 多线程]
group: archive
icon: code
featured: false
---
#+END_HTML
* 线程简述
** 线程类型
1.主线程：当一个程序启动时，就有一个进程被操作系统（OS）创建，与此同时一个线程也立刻运行，该线程通常叫做程序的主线程（Main Thread）。每个进程至少都有一个主线程，主线程通常最后关闭。
2.子线程：在程序中创建的其他线程，相对于主线程来说就是这个主线程的子线程。
3.守护线程：daemon thread，对线程的一种标识。守护线程为其他线程提供服务，如JVM的垃圾回收线程。当剩下的全是守护线程时，进程退出。
4.前台线程：相对于守护线程的其他线程称为前台线程。
** 线程的生命周期
#+BEGIN_HTML
<img src ="/images/2013-10/thread_state.jpg"/>
#+END_HTML
各状态说明如下：
1.New新建。新创建的线程经过初始化后，进入Runnable状态。
2.Runnable就绪。等待线程调度。调度后进入运行状态。
3.Running运行。
4.Blocked阻塞。暂停运行，解除阻塞后进入Runnable状态重新等待调度。
5.Dead消亡。线程方法执行完毕返回或者异常终止。



 
一般一个条件表达式都是在一个互斥锁的保护下被检查。当条件表达式未被满足时，线程将仍然阻塞在这个条件变量上。当另一个线程改变了条件的值并向条件变量发出信号时，等待在这个条件变量上的一个线程或所有线程被唤醒，接着都试图再次占有相应的互斥锁。

阻塞在条件变量上的线程被唤醒以后

 有的时候仅仅依靠锁住共享资源来使用它是不够的。有时候共享资源只有某些状态的时候才能够使用。比方说，某个线程如果要从堆栈中读取数据，那么如果栈中没有数据就必须等待数据被压栈。这种情况下的同步使用互斥锁是不够的。另一种同步的方式－－条件变量，就可以使用在这种情况下。

      条件变量的使用总是和互斥锁及共享资源联系在一起的。线程首先锁住互斥锁，然后检验共享资源的状态是否处于可使用的状态。如果不是，那么线程就要等待条件变量。要指向这样的操作就必须在等待的时候将互斥锁解锁，以便其他线程可以访问共享资源并改变其状态。它还得保证从等到得线程返回时互斥体是被上锁得。当另一个线程改变了共享资源的状态时，它就要通知正在等待条件变量的线程，使之重新变回被互斥锁阻塞的线程。

条件变量使我们可以睡眠等待某种条件出现。
       条件变量是利用线程间共享的全局变量进行同步的一种机制，主要包括两个动作：一个线程等待"条件变量的激活"而挂起；另一个线程使"条件变量激活"。为了防止竞争，条件变量的使用总是和一个互斥锁结合在一起。

一个生产者获取到锁，生产条件不满足，执行wait，释放锁并进入睡眠状态，线程登记进入waiting池
一个消费者获得锁，满足消费条件，改变条件，并发出通知。条件变量从waiting池中挑选一个线程通知其acquire(睡眠的线程被唤醒)
notifyall方法通知waiting池中的所有线程尝试acquire内部锁。由于上述机制，处于waiting状态的线程只能通过notify方法唤醒，所以notifyAll的作用在于防止有线程永远处于沉默状态。notify方法其实属于线程间通信
